\documentclass{article}
\usepackage{graphicx}

\setlength{\parindent}{0pt}
\setlength{\parskip}{5pt}

\begin{document}

\title{UADE 2.xx design specification}
\author{Heikki Orsila $<$heikki.orsila@iki.fi$>$}
\date{}
\maketitle

\section{History}

UADE 1.xx was written to be a stand-alone program that had separate code
for each possible \emph{frontend} (\emph{user interface}), but there was
no internal structure to implement different frontends easily. By much
hacking some kind of pseudo-interface was created to facilitate following
frontends:
\begin{itemize}
  \item Beep Media Player
  \item MorphOS shell without interaction
  \item Unix shell without interaction
  \item Unix shell with small interaction
  \item XMMS plugin
\end{itemize}

It was a clear design problem that needed to be fixed. To force the separation
of frontend and \emph{uadecore} (emulator), UADE 2.xx removed all user
interface issues from the uadecore.

\section{Message-passing protocol}
In UADE 2.xx the emulator (uadecore) became an independent process without
any user interfaces. Any frontend, or client, that wants to use its services
must communicate with the uadecore by using a token-passing based messaging
protocol. The protocol is of course implemented by interprocess communication
(IPC).

The basic idea of the protocol is that the frontend is the client
who issues commands for the server (uadecore). Uadecore may not send any
commands at all. Uadecore only sends replies to commands issued by the
client. Also, the client never replies anything back to the
uadecore.

The communication protocol is based on the concept of
\emph{tokens}. Only the party that has a token (there is only one) may
send messages. Messages are either commands or replies. Client sends
messages and uadecore sends replies. Both of them have to send the token back
sometimes. The party that doesn't have the token must reply to all commands
sent by the other party.

\subsection{Messaging protocol commands}

The messaging protocol has following commands which are only sent by
the client. There is an exception, however. The uadecore may send a
\emph{token}-command, but it is not really considered a command.
All the commands can be found from the file \mbox{src/include/uademsg.h}.

\begin{description}
\item [Config] command is used to pass a file name of the emulation
configuration file for the uadecore. The file is named \emph{uaerc}.

\item [Score] command is used to pass file name of a binary run-time in M68k
machine language for the uadecore. The binary run-time is called
\emph{score} or \emph{sound core}. The sound core contains implementations of
\emph{Eagleplayer} and \emph{AmigaOS} APIs.

\item [Player] command is used to pass a file name of a binary player plugin
in M68k machine language for the uadecore. This is also called an
\emph{Eagleplayer plugin}.

\item [Module] command is used to pass a file name of a song to be played
for the uadecore.

\item [Read] command is used to request more sound data from the uadecore.

\item [Reboot] command is used to halt playback synthesis of uadecore.

\item [Set subsong] command is used to set the initial subsong for playback.

\item [Ignore check] command is not necessary (will be documented later,
if ever).
\item [Song end not possible] command is not necessary.
\item [Set ntsc] command is not necessary.
\item [Filter] command is not necessary.
\item [Set interpolation mode] command is not necessary.
\item [Speed hack] command is not necessary.
\item [Change subsong] command is not necessary.
\item [Activate debugger] command is not necessary.

\item [Token] command is used to pass back the token for the other party.
\end{description}

\subsection{Messaging protocol replies for commands}

Messages are answered by following replies.
All the replies can be found from the file \mbox{src/include/uademsg.h}.

\begin{description}
\item [MSG] reply is just any random text string message that the client should
know. Could be spam, blackmailing, empty threats or last words of a dying
process.
\item [Can't play] reply is issued by the uadecore if it is not able to play
a given triplet of score, player and module.
\item [Can play] reply is issued by the uadecore if it can play a given
triplet of score, player and module.
\item [Song end] reply is issued by the uadecore to indicate that playback
has ended.
\item [Subsong info] is issued by the uadecore when it knows the amount of
subsongs contained in the song. This happens a short while after playback
has started, or usually during the first fraction of a second since
playback has been started.
\item [Player name] is a reply containing the human (geek?) readable player
name that is decoded by the eagleplayer plugin,
\item [Module name] is a reply containing the human readable form of the
module name decoded by the eagleplayer plugin.
\item [Format name] is a reply containing the human readable form
of the song format that is being played.
\item [Data] reply is issued by the uadecore to pass synthesized sample
data back to the client. This is a reply for the \emph{read}-command.
\end{description}.

\subsection{Message format}
All messages are sent as finite sized byte sequences. Each message begins
with a header:

\begin{center}
\begin{tabular}{|r|l|}
\hline
\textbf{uint32\_t} & msgtype \\
\hline
\textbf{uint32\_t} & size \\
\hline
\textbf{uint8\_t} & data[] \\
\hline
\end{tabular}
\end{center}

\emph{msgtype} field is simply an unsigned 32-bit integer in a packed
binary structure. Its C language definition is simply:
\begin{verbatim}
struct uade_msg {
  uint32_t msgtype;
  uint32_t size;
  uint8_t data[];
} __attribute__((packed));
\end{verbatim}

The \emph{size} field is 32-bit length of the bytes coming after the header.
Notice the use of C99 empty record in a structure (excuse the annoying GCC
feature there that forces the structure to be tightly packed). It has zero
size and thus the whole message size in memory is $8 + size$ bytes.

There are 3 types of messages: short messages, string messages and custom
messages. Each follow the given low-level format but the contents differs.

\subsubsection{Short message}

Short message has the value $0$ in \emph{size} field implying that there is
no special payload with the message. Sending a token, for example, is such
a message. All messages being short messages are:
\begin{center}
\begin{tabular}{|r|l|}
\hline
Command & Activate debugger\\
\hline
Command & Ignore check\\
\hline
Command & Reboot \\
\hline
Command & Song end not possible \\
\hline
Command & Speed hack \\
\hline
Command & Token \\
\hline
Reply & Can play\\
\hline
Reply & Can't play\\
\hline
\end{tabular}
\end{center}

\begin{figure}
\centering
\includegraphics[scale=0.25]{play_loop_state_diagram.eps}
\caption{Play loop interaction from client (frontend) perspective}
\label{fig:playloop}
\end{figure}

\end{document}
